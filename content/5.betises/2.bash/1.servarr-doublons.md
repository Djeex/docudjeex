---
navigation: true
title: Doublons servarr
main:
  fluid: false
---
:ellipsis{left=0px width=40rem top=10rem blur=140px}

# Detection de doublons et remplacement par des hardlinks
---

Six mois apr√®s avoir t√©l√©charg√© des t√©rabytes de media, je me suis rendu compte que Sonarr et Radarr les copaient dans ma biblio Plex au lieu de cr√©er des hardlinks. C'est d√ª √† un m√©canisme contre intuitif qui est que si vous montez plusieurs dossiers dans Sonarr/Radarr, il les voit comme deux systemes de fichiers diff√©rents. Et ne peut donc pas cr√©er de hardlinks. C'est pour cela qu'il ne faut monter qu'un seul dossier parent, qui contient tous les enfants (`downloads`, `movies`, `tvseries` dans le dossier parent `media` par exemple).

J'ai donc restructur√© mes dossiers, remis √† la main chaque chemin dans Qbittorrent, Plex, et autres. Il restait √† trouver un moyen de d√©tecter les doublons existants et d'automatiquement les supprimer et de cr√©er des hardlinks √† la place, pour √©conomiser de l'espace.

Mes dossiers :

```console
.
‚îî‚îÄ‚îÄ media
    ‚îú‚îÄ‚îÄ seedbox
    ‚îú‚îÄ‚îÄ radarr
    ‚îÇ   ‚îî‚îÄ‚îÄ tv-radarr
    ‚îú‚îÄ‚îÄ movies
    ‚îî‚îÄ‚îÄ tvseries
```

Mes dossiers originaux sont dans `seedbox`, et il ne faut surtout pas les modifier pour qu'ils continuent d'etre "seed". Les copies, et donc doublons, sont dans `movies` et `tvseries`. Mais pour complexifier la chose, j'ai aussi des media uniques originaux d√©pos√©s par ailleurs dans `movies` et `tvseries`, sinon cela serait trop facile. Et dans ces deux dossiers, il peut y avoir des sous dossiers, des sous-sous dossiers, etc. 

L'id√©e est donc de : 

- lister les originaux dans seedbox
- lister les fichiers dans movies
- comparer les deux listes et isoler les chemins des doublons
- supprimer les doublons
- hardlinker les originaux dans les dossiers des doublons supprim√©s

Alors oui j'ai demand√© √† ChatGPT et √† Qwen3 (que j'h√©berge sur une machine d√©di√©e √† l'IA). Et evidemment ils m'ont conseill√© les rfind, rdfind, dupes, rdupes, rmlint... Mais comparer les hash de 30TB de media, faudrait plusieurs jours, j'ai vite abandonn√©.

Au final, je n'ai que des `.mkv` √† chercher et les doublons ont exactement les m√™mes noms que les originaux, ce qui simplifie grandement la t√¢che. Un simple script bash devait donc √™tre suffisant.

Je vous passe les incessantes questions r√©ponses avec ChatGPT, je suis assez d√©√ßu. Qwen3 a √©t√© bien plus propre. ChatGPT n'a pas cess√© de mettre des solutions type awk, qui p√®tent la lecture des chemins au moindre espace. En faisant relire √† Qwen, et en lui demandant de se passer de awk, le r√©sultat a √©t√© immediatement plus qualitatif.

Pour tester, j'ai d'abord demand√© un script qui ne fait que lister et comparer :

```bash
#!/bin/bash

# Cr√©er un tableau associatif pour stocker les doublons
declare -A seen

# Trouver tous les fichiers .mkv uniquement (exclure les dossiers)
find /media/seedbox /media/movies /media/tvseries -type f -name "*.mkv" -print0 | \
while IFS= read -r -d '' file; do
    # Obtenir l'inode du fichier et son chemin
    inode=$(stat --format="%i" "$file")
    filename=$(basename "$file")
    
    # Si ce nom de fichier a d√©j√† √©t√© vu
    if [[ -n "${seen[$filename]}" ]]; then
        # V√©rifier si l'inode est diff√©rent du pr√©c√©dent
        if [[ "${seen[$filename]}" != "$inode" ]]; then
            # Ajouter le doublon √† la sortie en affichant les chemins complets
            echo "Doublons pour \"$filename\" :"
            echo "${seen["$filename"]} ${seen["$filename:full_path"]}"
            echo "$inode $file"
            echo
        fi
    else
        # Si c'est la premi√®re fois qu'on rencontre ce nom de fichier
        seen[$filename]="$inode"
        seen["$filename:full_path"]="$file"
    fi
done
```

J'ai ainsi obtenu ce type de r√©ponse :

```
Doublons pour "episode1.mkv" :
1234567 /media/seedbox/sonarr/Serie 1/Season1/episode1.mkv
2345678 /media/tvseries/Serie 1/Season1/episode1.mkv
```

Avec "awk", il se serait arr√™t√© √†  `/media/seedbox/sonarr/Serie`. Je ne suis absolument pas un pro, mais Qwen3 a √©t√© plus performant et m'a expliqu√© de A √† Z pourquoi et comment faire.

Une fois que j'ai vu que cela fonctionnait bien, j'ai demand√© un script qui fait l'int√©gralit√© de la cin√©matique, de la comparaison aux hardlinks en passant par la suppression des doublons.
Encore une fois ChatGPT a √©t√© d√©cevant. Malgr√© mes demandes, il cr√©ait d'abord les hardlinks et ensuite il supprimait les doublons. Ce qui.. suprimme aussi le lien (meme si cela conserve l'originale). Idiot.
Petit d√©tour par Qwen3, et ma RTX 5090 en PLS, et paf un r√©sultat bien plus propre. Bon il a gard√© les emoji de ChatGPT qui peut pas s'empecher d'en mettre partout, mais voil√† :

```bash
#!/bin/bash

echo "üîç √âtape 1 : Indexation des fichiers originaux dans /media/seedbox..."
declare -A seen

# Indexe tous les .mkv dans seedbox
while IFS= read -r -d '' file; do
    filename=$(basename "$file")
    seen["$filename"]="$file"
done < <(find /media/seedbox -type f -name "*.mkv" -print0)

echo "üì¶ √âtape 2 : Remplacement automatique des doublons..."
total_doublons=0
total_ko_economises=0

while IFS= read -r -d '' file; do
    filename=$(basename "$file")
    original="${seen[$filename]}"

    if [[ -n "$original" && "$original" != "$file" ]]; then
        inode_orig=$(stat -c %i "$original")
        inode_dupe=$(stat -c %i "$file")

        if [[ "$inode_orig" != "$inode_dupe" ]]; then
            size_kb=$(du -k "$file" | cut -f1)
            echo "üîÅ Remplacement :"
            echo "    Doublon   : $file"
            echo "    Original  : $original"
            echo "    Taille    : ${size_kb} Ko"

            rm "$file" && ln "$original" "$file" && echo "‚úÖ Hardlink cr√©√©."

            total_doublons=$((total_doublons + 1))
            total_ko_economises=$((total_ko_economises + size_kb))
        fi
    fi
done < <(find /media/movies /media/tvseries -type f -name "*.mkv" -print0)

echo ""
echo "üßæ R√©sum√© :"
echo "    üîó Doublons remplac√©s par hardlink : $total_doublons"
echo "    üíæ Espace disque √©conomis√© approximatif : ${total_ko_economises} Ko (~$((total_ko_economises / 1024)) Mo)"
echo "‚úÖ Termin√©."
```

Bilan j'ai :
- appris pas mal de subtilit√© bash
- appris qu'il ne faut jamais copier coller un script g√©n√©r√© ChatGPT sans le comprendre et sans le tester en dry-run
- appris que Qwen sur une RTX 5090 est plus coh√©rent que ChatGPT 4o sur des fermes de serveurs (je vous passe les r√©sultats de la version "normale").
- appris que m√™me quand on a 100TB d'espace, monitorer ce dernier m'aurait permis de voir beaucoup plus tot que j'avais 12TB de doublons qui trainent.

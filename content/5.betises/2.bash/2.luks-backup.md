---
navigation: true
title: Luks backup
main:
  fluid: false
---
:ellipsis{left=0px width=40rem top=10rem blur=140px}
# Backup des headers luks pour disques/volumes chiffr√©s
---

Je me suis rendu compte il y a peu qu'il ne suffisait pas d'avoir le mot de passe pour deverouiller un volume luks apres une panne ou une corruption. J'ai ainsi appris √† dump les headers luks des disques/volumes et √† utiliser les num√©ros de s√©rie + noms de partitions pour pouvoir bien identifier quel header correspond √† quel disque/partition (j'en ai 10 !).

Apr√®s avoir bien gal√©r√© √† la main, j'avoue avoir demand√© √† Qwen3 (llm heberg√© sur ma RTX 5090) de me faire un script qui automatise le listing et identification des disques, dump les headers et les stock dans une archive chiffr√©e prete √† etre backup√©e sur mon serveur de sauvegarde.

Ainsi, ce script :
* Liste et identifie les disques avec leur num√©ro de s√©rie
* Liste les partition
* Dump les headers dans un dossier dans `/root` (dossier s√©curis√©)
* Cree une archive temporaire
* Prompt pour saisir un mot de passe
* Chiffre avec le mot de passe
* D√©truit l'archive non chiffr√©e

```
#!/bin/bash

# Directory where LUKS headers will be backed up
DEST="/root/luks-headers-backup"
mkdir -p "$DEST"

echo "üîç Searching for LUKS containers on all partitions..."

# Loop through all possible disk partitions (including NVMe and SATA)
for part in /dev/sd? /dev/sd?? /dev/nvme?n?p?; do
    # Skip if the device doesn't exist
    if [ ! -b "$part" ]; then
        continue
    fi

    # Check if the partition is a LUKS encrypted volume
    if cryptsetup isLuks "$part"; then
        # Find the parent disk device (e.g. nvme0n1p4 ‚Üí nvme0n1)
        disk=$(lsblk -no pkname "$part" | head -n 1)
        full_disk="/dev/$disk"

        # Get the serial number of the parent disk
        SERIAL=$(udevadm info --query=all --name="$full_disk" | grep ID_SERIAL= | cut -d= -f2)
        if [ -z "$SERIAL" ]; then
            SERIAL="unknown"
        fi

        # Extract the partition name (e.g. nvme0n1p4)
        PART_NAME=$(basename "$part")

        # Build the output filename with partition name and disk serial
        OUTPUT="$DEST/luks-header-${PART_NAME}__${SERIAL}.img"

        echo "üîê Backing up LUKS header of $part (Serial: $SERIAL)..."

        # Backup the LUKS header to the output file
        cryptsetup luksHeaderBackup "$part" --header-backup-file "$OUTPUT"
        if [[ $? -eq 0 ]]; then
            echo "‚úÖ Backup successful ‚Üí $OUTPUT"
        else
            echo "‚ùå Backup failed for $part"
        fi
    fi
done

# Create a timestamped compressed tar archive of all header backups
ARCHIVE_NAME="/root/luks-headers-$(date +%Y%m%d_%H%M%S).tar.gz"
echo "üì¶ Creating archive $ARCHIVE_NAME..."
tar -czf "$ARCHIVE_NAME" -C "$DEST" .

# Encrypt the archive symmetrically using GPG with AES256 cipher
echo "üîê Encrypting the archive with GPG..."
gpg --symmetric --cipher-algo AES256 "$ARCHIVE_NAME"
if [[ $? -eq 0 ]]; then
    echo "‚úÖ Encrypted archive created: ${ARCHIVE_NAME}.gpg"
    # Remove the unencrypted archive for security
    rm -f "$ARCHIVE_NAME"
else
    echo "‚ùå Encryption failed"
fi
```

Ne pas oublier de backup `/etc/fstab` et `/etc/crypttab` !
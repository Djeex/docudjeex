---
navigation: true
title: Scripts bash
main:
  fluid: false
---
:ellipsis{left=0px width=40rem top=10rem blur=140px}
# Scripts bash

Quelques scripts en vracs qui m'ont sauv√© la vie.

## Detection de doublons et remplacement par des hardlinks
---

Six mois apr√®s avoir t√©l√©charg√© des t√©rabytes de media, je me suis rendu compte que Sonarr et Radarr les copaient dans ma biblio Plex au lieu de cr√©er des hardlinks. C'est d√ª √† un m√©canisme contre intuitif qui est que si vous montez plusieurs dossiers dans Sonarr/Radarr, il les voit comme deux systemes de fichiers diff√©rents. Et ne peut donc pas cr√©er de hardlinks. C'est pour cela qu'il ne faut monter qu'un seul dossier parent, qui contient tous les enfants (`downloads`, `movies`, `tvseries` dans le dossier parent `media` par exemple).

J'ai donc restructur√© mes dossiers, remis √† la main chaque chemin dans Qbittorrent, Plex, et autres. Il restait √† trouver un moyen de d√©tecter les doublons existants et d'automatiquement les supprimer et de cr√©er des hardlinks √† la place, pour √©conomiser de l'espace.

Mes dossiers :

```console
.
‚îî‚îÄ‚îÄ media
    ‚îú‚îÄ‚îÄ seedbox
    ‚îú‚îÄ‚îÄ radarr
    ‚îÇ   ‚îî‚îÄ‚îÄ tv-radarr
    ‚îú‚îÄ‚îÄ movies
    ‚îî‚îÄ‚îÄ tvseries
```

Mes dossiers originaux sont dans `seedbox`, et il ne faut surtout pas les modifier pour qu'ils continuent d'etre "seed". Les copies, et donc doublons, sont dans `movies` et `tvseries`. Mais pour complexifier la chose, j'ai aussi des media uniques originaux d√©pos√©s par ailleurs dans `movies` et `tvseries`, sinon cela serait trop facile. Et dans ces deux dossiers, il peut y avoir des sous dossiers, des sous-sous dossiers, etc. 

L'id√©e est donc de : 

- lister les originaux dans seedbox
- lister les fichiers dans movies
- comparer les deux listes et isoler les chemins des doublons
- supprimer les doublons
- hardlinker les originaux dans les dossiers des doublons supprim√©s

Alors oui j'ai demand√© √† ChatGPT et √† Qwen3 (que j'h√©berge sur une machine d√©di√©e √† l'IA). Et evidemment ils m'ont conseill√© les rfind, rdfind, dupes, rdupes, rmlint... Mais comparer les hash de 30TB de media, faudrait plusieurs jours, j'ai vite abandonn√©.

Au final, je n'ai que des `.mkv` √† chercher et les doublons ont exactement les m√™mes noms que les originaux, ce qui simplifie grandement la t√¢che. Un simple script bash devait donc √™tre suffisant.

Je vous passe les incessantes questions r√©ponses avec ChatGPT, je suis assez d√©√ßu. Qwen3 a √©t√© bien plus propre. ChatGPT n'a pas cess√© de mettre des solutions type awk, qui p√®tent la lecture des chemins au moindre espace. En faisant relire √† Qwen, et en lui demandant de se passer de awk, le r√©sultat a √©t√© immediatement plus qualitatif.

Pour tester, j'ai d'abord demand√© un script qui ne fait que lister et comparer :

```bash
#!/bin/bash

# Cr√©er un tableau associatif pour stocker les doublons
declare -A seen

# Trouver tous les fichiers .mkv uniquement (exclure les dossiers)
find /media/seedbox /media/movies /media/tvseries -type f -name "*.mkv" -print0 | \
while IFS= read -r -d '' file; do
    # Obtenir l'inode du fichier et son chemin
    inode=$(stat --format="%i" "$file")
    filename=$(basename "$file")
    
    # Si ce nom de fichier a d√©j√† √©t√© vu
    if [[ -n "${seen[$filename]}" ]]; then
        # V√©rifier si l'inode est diff√©rent du pr√©c√©dent
        if [[ "${seen[$filename]}" != "$inode" ]]; then
            # Ajouter le doublon √† la sortie en affichant les chemins complets
            echo "Doublons pour \"$filename\" :"
            echo "${seen["$filename"]} ${seen["$filename:full_path"]}"
            echo "$inode $file"
            echo
        fi
    else
        # Si c'est la premi√®re fois qu'on rencontre ce nom de fichier
        seen[$filename]="$inode"
        seen["$filename:full_path"]="$file"
    fi
done
```

J'ai ainsi obtenu ce type de r√©ponse :

```
Doublons pour "episode1.mkv" :
1234567 /media/seedbox/sonarr/Serie 1/Season1/episode1.mkv
2345678 /media/tvseries/Serie 1/Season1/episode1.mkv
```

Avec "awk", il se serait arr√™t√© √†  `/media/seedbox/sonarr/Serie`. Je ne suis absolument pas un pro, mais Qwen3 a √©t√© plus performant et m'a expliqu√© de A √† Z pourquoi et comment faire.

Une fois que j'ai vu que cela fonctionnait bien, j'ai demand√© un script qui fait l'int√©gralit√© de la cin√©matique, de la comparaison aux hardlinks en passant par la suppression des doublons.
Encore une fois ChatGPT a √©t√© d√©cevant. Malgr√© mes demandes, il cr√©ait d'abord les hardlinks et ensuite il supprimait les doublons. Ce qui.. suprimme aussi le lien (meme si cela conserve l'originale). Idiot.
Petit d√©tour par Qwen3, et ma RTX 5090 en PLS, et paf un r√©sultat bien plus propre. Bon il a gard√© les emoji de ChatGPT qui peut pas s'empecher d'en mettre partout, mais voil√† :

```bash
#!/bin/bash

echo "üîç √âtape 1 : Indexation des fichiers originaux dans /media/seedbox..."
declare -A seen

# Indexe tous les .mkv dans seedbox
while IFS= read -r -d '' file; do
    filename=$(basename "$file")
    seen["$filename"]="$file"
done < <(find /media/seedbox -type f -name "*.mkv" -print0)

echo "üì¶ √âtape 2 : Remplacement automatique des doublons..."
total_doublons=0
total_ko_economises=0

while IFS= read -r -d '' file; do
    filename=$(basename "$file")
    original="${seen[$filename]}"

    if [[ -n "$original" && "$original" != "$file" ]]; then
        inode_orig=$(stat -c %i "$original")
        inode_dupe=$(stat -c %i "$file")

        if [[ "$inode_orig" != "$inode_dupe" ]]; then
            size_kb=$(du -k "$file" | cut -f1)
            echo "üîÅ Remplacement :"
            echo "    Doublon   : $file"
            echo "    Original  : $original"
            echo "    Taille    : ${size_kb} Ko"

            rm "$file" && ln "$original" "$file" && echo "‚úÖ Hardlink cr√©√©."

            total_doublons=$((total_doublons + 1))
            total_ko_economises=$((total_ko_economises + size_kb))
        fi
    fi
done < <(find /media/movies /media/tvseries -type f -name "*.mkv" -print0)

echo ""
echo "üßæ R√©sum√© :"
echo "    üîó Doublons remplac√©s par hardlink : $total_doublons"
echo "    üíæ Espace disque √©conomis√© approximatif : ${total_ko_economises} Ko (~$((total_ko_economises / 1024)) Mo)"
echo "‚úÖ Termin√©."
```

Bilan j'ai :
- appris pas mal de subtilit√© bash
- appris qu'il ne faut jamais copier coller un script g√©n√©r√© ChatGPT sans le comprendre et sans le tester en dry-run
- appris que Qwen sur une RTX 5090 est plus coh√©rent que ChatGPT 4o sur des fermes de serveurs (je vous passe les r√©sultats de la version "normale").
- appris que m√™me quand on a 100TB d'espace, monitorer ce dernier m'aurait permis de voir beaucoup plus tot que j'avais 12TB de doublons qui trainent.

## Backup des headers luks pour disques/volumes chiffr√©s
---

Je me suis rendu compte il y a peu qu'il ne suffisait pas d'avoir le mot de passe pour deverouiller un volume luks apres une panne ou une corruption. J'ai ainsi appris √† dump les headers luks des disques/volumes et √† utiliser les num√©ros de s√©rie + noms de partitions pour pouvoir bien identifier quel header correspond √† quel disque/partition (j'en ai 10 !).

Apr√®s avoir bien gal√©r√© √† la main, j'avoue avoir demand√© √† Qwen3 (llm heberg√© sur ma RTX 5090) de me faire un script qui automatise le listing et identification des disques, dump les headers et les stock dans une archive chiffr√©e prete √† etre backup√©e sur mon serveur de sauvegarde.

Ainsi, ce script :
* Liste et identifie les disques avec leur num√©ro de s√©rie
* Liste les partition
* Dump les headers dans un dossier dans `/root` (dossier s√©curis√©)
* Cree une archive temporaire
* Prompt pour saisir un mot de passe
* Chiffre avec le mot de passe
* D√©truit l'archive non chiffr√©e

```
#!/bin/bash

# Directory where LUKS headers will be backed up
DEST="/root/luks-headers-backup"
mkdir -p "$DEST"

echo "üîç Searching for LUKS containers on all partitions..."

# Loop through all possible disk partitions (including NVMe and SATA)
for part in /dev/sd? /dev/sd?? /dev/nvme?n?p?; do
    # Skip if the device doesn't exist
    if [ ! -b "$part" ]; then
        continue
    fi

    # Check if the partition is a LUKS encrypted volume
    if cryptsetup isLuks "$part"; then
        # Find the parent disk device (e.g. nvme0n1p4 ‚Üí nvme0n1)
        disk=$(lsblk -no pkname "$part" | head -n 1)
        full_disk="/dev/$disk"

        # Get the serial number of the parent disk
        SERIAL=$(udevadm info --query=all --name="$full_disk" | grep ID_SERIAL= | cut -d= -f2)
        if [ -z "$SERIAL" ]; then
            SERIAL="unknown"
        fi

        # Extract the partition name (e.g. nvme0n1p4)
        PART_NAME=$(basename "$part")

        # Build the output filename with partition name and disk serial
        OUTPUT="$DEST/luks-header-${PART_NAME}__${SERIAL}.img"

        echo "üîê Backing up LUKS header of $part (Serial: $SERIAL)..."

        # Backup the LUKS header to the output file
        cryptsetup luksHeaderBackup "$part" --header-backup-file "$OUTPUT"
        if [[ $? -eq 0 ]]; then
            echo "‚úÖ Backup successful ‚Üí $OUTPUT"
        else
            echo "‚ùå Backup failed for $part"
        fi
    fi
done

# Create a timestamped compressed tar archive of all header backups
ARCHIVE_NAME="/root/luks-headers-$(date +%Y%m%d_%H%M%S).tar.gz"
echo "üì¶ Creating archive $ARCHIVE_NAME..."
tar -czf "$ARCHIVE_NAME" -C "$DEST" .

# Encrypt the archive symmetrically using GPG with AES256 cipher
echo "üîê Encrypting the archive with GPG..."
gpg --symmetric --cipher-algo AES256 "$ARCHIVE_NAME"
if [[ $? -eq 0 ]]; then
    echo "‚úÖ Encrypted archive created: ${ARCHIVE_NAME}.gpg"
    # Remove the unencrypted archive for security
    rm -f "$ARCHIVE_NAME"
else
    echo "‚ùå Encryption failed"
fi
```

Ne pas oublier de backup `/etc/fstab` et `/etc/crypttab` !